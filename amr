#!/bin/bash
# Created:  Wed 23 Apr 2014 12:58 pm
# Author:   Josh Wainwright
# Filename: amr (All My Repos)

set -o nounset
#set -o errexit

verbose=false
justList=false
pullAll=false
pushAll=false
commit=false
list=""
ignore=("Osaka" "plugged" "TLPs")
include=("JoshWainwright" "josh")
customcmd=""

verbose() {
	set +u
	if $verbose; then
		echo -e ${2} "$1"
	fi
	set -u
}

usage() {
	b="\033[4m"
	n="\033[0m"
helptext="$(basename $0) [-hvlduc] [-x pattern] [-i pattern] [-r command]

amr = ${b}A${n}ll ${b}M${n}y ${b}R${n}epos. Perform actions on all the repositories found on the local machine.

	-h         Show this ${b}h${n}elp text.
	-v         Be more ${b}v${n}erbose with output text.
	-l         Don't perform any actions, simply ${b}l${n}ist the repos found.
	-d         Pull ${b}d${n}own changes from remotes (git pull).
	-u         Push ${b}u${n}p commits to remotes (git push).
	-c         Interactively ${b}c${n}ommit local changes.
	-x pattern E${b}x${n}clude any repos matching pattern.
	-i pattern Only ${b}i${n}nclude repos that match patter.
	-r command ${b}R${n}un the command provided within every repo found.
"
echo -e "$helptext"
}

getGitRepos() {
	if hash locate 2>/dev/null; then
		list=$(dirname $(locate -br '\.git$'))
	else
		verbose "Command locate not availible. Using find instead."
		list=$(find ~/ -name ".git" -exec dirname {} \; 2> /dev/null)
	fi

	for i in "${ignore[@]}"; do
		list=$(sed "/${i}/d" <<< "$list")
	done

	if [[ ${#include[@]} -ne 0 ]]; then
		local includeString=""
		for i in "${include[@]}"; do
			includeString+="$i""|"
		done
		includeString=${includeString%?}
		list=$(egrep "$includeString" <<< "$list")
	fi

}

pullAll() {
	if $pullAll; then
		git -c color.pull=always pull origin master 2>&1 | sed 's/^/\t/'
	fi
}

pushAll() {
	if $pushAll; then
		if [[ $1 -gt 0 ]]; then
			git -c colour.push=always push 2>&1 | sed 's/^/\t/'
		fi
	fi
}

currentDir=$(pwd)
cd ~/

while getopts "hvlducx:i:r:" opt; do
	case "$opt" in
		h)
			usage
			exit 0
			;;
		v)
			verbose=true
			;;
		l)
			justList=true
			;;
		d)
			pullAll=true
			;;
		u)
			pushAll=true
			;;
		c)
			commit=true
			;;
		x)
			ignore+=("$OPTARG")
			;;
		i)
			include+=("$OPTARG")
			;;
		r)
			customcmd=("$OPTARG")
			;;
		*)
			echo "Flag "$opt" not recognised."
			exit 0
			;;
	esac
done
shift $((OPTIND-1))

#### Start script ####

getGitRepos

if $verbose; then
	echo "Ignore List:"
	printf -- '\t%s\n' "${ignore[@]}"
	echo "Include List:"
	printf -- '\t%s\n' "${include[@]}"
	echo
fi

if $justList; then
	echo "$list"
	exit
fi

# while read -r gitDir; do
for gitDir in $(echo $list); do

	addNewline=false
	cd $gitDir;

	echo "$gitDir"
	if ! git diff --quiet --ignore-submodules HEAD &>/dev/null; then

		numberLines=$(git status -s | wc -l);

		if [[ "$numberLines" != "0" ]]; then
			echo -e "\tChanged $numberLines"
			git -c color.status=always status --ignore-submodules --short | sed 's/^/\t/'
			addNewline=true
		fi

		if $commit; then
			git gui 2> /dev/null || zsh -i -c "gu"
		fi

	fi
	if [[ "x$customcmd" != "x" ]]; then
		eval "$customcmd" | sed 's/^/\t\t/'
	fi

	numberAhead=$(git log --branches --not --remotes --oneline 2> /dev/null | wc -l)
	if [[ "$numberAhead" -ne 0 ]]; then
		echo -e "\tAhead: $numberAhead"
		git log --color=always --branches --not --remotes --oneline --decorate | sed 's/^/\t/'
		addNewline=true
	fi

	pullAll
	pushAll $numberAhead

	if $addNewline; then
		echo
	fi

done <<< "$list"

cd $currentDir
